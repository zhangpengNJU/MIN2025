static FocusEvent retargetFocusGained(FocusEvent fe) {
    assert (fe.getID() == FocusEvent.FOCUS_GAINED);
    Component currentFocusOwner = getCurrentKeyboardFocusManager().getGlobalFocusOwner();
    Component source = fe.getComponent();
    Component opposite = fe.getOppositeComponent();
    Component nativeSource = getHeavyweight(source);
    synchronized (heavyweightRequests) {
        HeavyweightFocusRequest hwFocusRequest = getFirstHWRequest();
        if (hwFocusRequest == HeavyweightFocusRequest.CLEAR_GLOBAL_FOCUS_OWNER) {
            return retargetUnexpectedFocusEvent(fe);
        }
        if (source != null && nativeSource == null && hwFocusRequest != null) {
            // if source w/o peer and
            // if source is equal to first lightweight
            // then we should correct source and nativeSource
            if (source == hwFocusRequest.getFirstLightweightRequest().component) {
                source = hwFocusRequest.heavyweight;
                // source is heavuweight itself
                nativeSource = source;
            }
        }
        if (hwFocusRequest != null && nativeSource == hwFocusRequest.heavyweight) {
            // Focus change as a result of a known call to requestFocus(),
            // or known click on a peer focusable heavyweight Component.
            heavyweightRequests.removeFirst();
            LightweightFocusRequest lwFocusRequest = hwFocusRequest.lightweightRequests.removeFirst();
            Component newSource = lwFocusRequest.component;
            if (currentFocusOwner != null) {
                /*
                     * Since we receive FOCUS_GAINED when current focus
                     * owner is not null, correcponding FOCUS_LOST is supposed
                     * to be lost.  And so,  we keep new focus owner
                     * to determine synthetic FOCUS_LOST event which will be
                     * generated by KeyboardFocusManager for this FOCUS_GAINED.
                     *
                     * This code based on knowledge of
                     * DefaultKeyboardFocusManager's implementation and might
                     * be not applicable for another KeyboardFocusManager.
                     */
                newFocusOwner = newSource;
            }
            boolean temporary = (opposite == null || isTemporary(newSource, opposite)) ? false : lwFocusRequest.temporary;
            if (hwFocusRequest.lightweightRequests.size() > 0) {
                currentLightweightRequests = hwFocusRequest.lightweightRequests;
                EventQueue.invokeLater(new Runnable() {

                    public void run() {
                        processCurrentLightweightRequests();
                    }
                });
            }
            // 'opposite' will be fixed by
            // DefaultKeyboardFocusManager.realOppositeComponent
            return new CausedFocusEvent(newSource, FocusEvent.FOCUS_GAINED, temporary, opposite, lwFocusRequest.cause);
        }
        if (currentFocusOwner != null && currentFocusOwner.getContainingWindow() == source && (hwFocusRequest == null || source != hwFocusRequest.heavyweight)) {
            // Special case for FOCUS_GAINED in top-levels
            // If it arrives as the result of activation we should skip it
            // This event will not have appropriate request record and
            // on arrival there will be already some focus owner set.
            return new CausedFocusEvent(currentFocusOwner, FocusEvent.FOCUS_GAINED, false, null, CausedFocusEvent.Cause.ACTIVATION);
        }
        return retargetUnexpectedFocusEvent(fe);
    }
// end synchronized(heavyweightRequests)
}