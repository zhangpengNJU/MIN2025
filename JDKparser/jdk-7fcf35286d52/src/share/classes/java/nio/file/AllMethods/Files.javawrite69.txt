/**
 * Writes bytes to a file. The {@code options} parameter specifies how the
 * the file is created or opened. If no options are present then this method
 * works as if the {@link StandardOpenOption#CREATE CREATE}, {@link
 * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link
 * StandardOpenOption#WRITE WRITE} options are present. In other words, it
 * opens the file for writing, creating the file if it doesn't exist, or
 * initially truncating an existing {@link #isRegularFile regular-file} to
 * a size of {@code 0}. All bytes in the byte array are written to the file.
 * The method ensures that the file is closed when all bytes have been
 * written (or an I/O error or other runtime exception is thrown). If an I/O
 * error occurs then it may do so after the file has created or truncated,
 * or after some bytes have been written to the file.
 *
 * <p> <b>Usage example</b>: By default the method creates a new file or
 * overwrites an existing file. Suppose you instead want to append bytes
 * to an existing file:
 * <pre>
 *     Path path = ...
 *     byte[] bytes = ...
 *     Files.write(path, bytes, StandardOpenOption.APPEND);
 * </pre>
 *
 * @param   path
 *          the path to the file
 * @param   bytes
 *          the byte array with the bytes to write
 * @param   options
 *          options specifying how the file is opened
 *
 * @return  the path
 *
 * @throws  IOException
 *          if an I/O error occurs writing to or creating the file
 * @throws  UnsupportedOperationException
 *          if an unsupported option is specified
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
 *          method is invoked to check write access to the file.
 */
public static Path write(Path path, byte[] bytes, OpenOption... options) throws IOException {
    // ensure bytes is not null before opening file
    Objects.requireNonNull(bytes);
    try (OutputStream out = Files.newOutputStream(path, options)) {
        int len = bytes.length;
        int rem = len;
        while (rem > 0) {
            int n = Math.min(rem, BUFFER_SIZE);
            out.write(bytes, (len - rem), n);
            rem -= n;
        }
    }
    return path;
}