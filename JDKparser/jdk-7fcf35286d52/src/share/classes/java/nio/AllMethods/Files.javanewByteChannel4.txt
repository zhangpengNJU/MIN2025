/**
 * Opens or creates a file, returning a seekable byte channel to access the
 * file.
 *
 * <p> The {@code options} parameter determines how the file is opened.
 * The {@link StandardOpenOption#READ READ} and {@link
 * StandardOpenOption#WRITE WRITE} options determine if the file should be
 * opened for reading and/or writing. If neither option (or the {@link
 * StandardOpenOption#APPEND APPEND} option) is present then the file is
 * opened for reading. By default reading or writing commence at the
 * beginning of the file.
 *
 * <p> In the addition to {@code READ} and {@code WRITE}, the following
 * options may be present:
 *
 * <table border=1 cellpadding=5 summary="Options">
 * <tr> <th>Option</th> <th>Description</th> </tr>
 * <tr>
 *   <td> {@link StandardOpenOption#APPEND APPEND} </td>
 *   <td> If this option is present then the file is opened for writing and
 *     each invocation of the channel's {@code write} method first advances
 *     the position to the end of the file and then writes the requested
 *     data. Whether the advancement of the position and the writing of the
 *     data are done in a single atomic operation is system-dependent and
 *     therefore unspecified. This option may not be used in conjunction
 *     with the {@code READ} or {@code TRUNCATE_EXISTING} options. </td>
 * </tr>
 * <tr>
 *   <td> {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} </td>
 *   <td> If this option is present then the existing file is truncated to
 *   a size of 0 bytes. This option is ignored when the file is opened only
 *   for reading. </td>
 * </tr>
 * <tr>
 *   <td> {@link StandardOpenOption#CREATE_NEW CREATE_NEW} </td>
 *   <td> If this option is present then a new file is created, failing if
 *   the file already exists or is a symbolic link. When creating a file the
 *   check for the existence of the file and the creation of the file if it
 *   does not exist is atomic with respect to other file system operations.
 *   This option is ignored when the file is opened only for reading. </td>
 * </tr>
 * <tr>
 *   <td > {@link StandardOpenOption#CREATE CREATE} </td>
 *   <td> If this option is present then an existing file is opened if it
 *   exists, otherwise a new file is created. This option is ignored if the
 *   {@code CREATE_NEW} option is also present or the file is opened only
 *   for reading. </td>
 * </tr>
 * <tr>
 *   <td > {@link StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} </td>
 *   <td> When this option is present then the implementation makes a
 *   <em>best effort</em> attempt to delete the file when closed by the
 *   {@link SeekableByteChannel#close close} method. If the {@code close}
 *   method is not invoked then a <em>best effort</em> attempt is made to
 *   delete the file when the Java virtual machine terminates. </td>
 * </tr>
 * <tr>
 *   <td>{@link StandardOpenOption#SPARSE SPARSE} </td>
 *   <td> When creating a new file this option is a <em>hint</em> that the
 *   new file will be sparse. This option is ignored when not creating
 *   a new file. </td>
 * </tr>
 * <tr>
 *   <td> {@link StandardOpenOption#SYNC SYNC} </td>
 *   <td> Requires that every update to the file's content or metadata be
 *   written synchronously to the underlying storage device. (see <a
 *   href="package-summary.html#integrity"> Synchronized I/O file
 *   integrity</a>). </td>
 * </tr>
 * <tr>
 *   <td> {@link StandardOpenOption#DSYNC DSYNC} </td>
 *   <td> Requires that every update to the file's content be written
 *   synchronously to the underlying storage device. (see <a
 *   href="package-summary.html#integrity"> Synchronized I/O file
 *   integrity</a>). </td>
 * </tr>
 * </table>
 *
 * <p> An implementation may also support additional implementation specific
 * options.
 *
 * <p> The {@code attrs} parameter is optional {@link FileAttribute
 * file-attributes} to set atomically when a new file is created.
 *
 * <p> In the case of the default provider, the returned seekable byte channel
 * is a {@link java.nio.channels.FileChannel}.
 *
 * <p> <b>Usage Examples:</b>
 * <pre>
 *     Path path = ...
 *
 *     // open file for reading
 *     ReadableByteChannel rbc = Files.newByteChannel(path, EnumSet.of(READ)));
 *
 *     // open file for writing to the end of an existing file, creating
 *     // the file if it doesn't already exist
 *     WritableByteChannel wbc = Files.newByteChannel(path, EnumSet.of(CREATE,APPEND));
 *
 *     // create file with initial permissions, opening it for both reading and writing
 *     {@code FileAttribute<Set<PosixFilePermission>> perms = ...}
 *     SeekableByteChannel sbc = Files.newByteChannel(path, EnumSet.of(CREATE_NEW,READ,WRITE), perms);
 * </pre>
 *
 * @param   path
 *          the path to the file to open or create
 * @param   options
 *          options specifying how the file is opened
 * @param   attrs
 *          an optional list of file attributes to set atomically when
 *          creating the file
 *
 * @return  a new seekable byte channel
 *
 * @throws  IllegalArgumentException
 *          if the set contains an invalid combination of options
 * @throws  UnsupportedOperationException
 *          if an unsupported open option is specified or the array contains
 *          attributes that cannot be set atomically when creating the file
 * @throws  FileAlreadyExistsException
 *          if a file of that name already exists and the {@link
 *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified
 *          <i>(optional specific exception)</i>
 * @throws  IOException
 *          if an I/O error occurs
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkRead(String) checkRead}
 *          method is invoked to check read access to the path if the file is
 *          opened for reading. The {@link SecurityManager#checkWrite(String)
 *          checkWrite} method is invoked to check write access to the path
 *          if the file is opened for writing. The {@link
 *          SecurityManager#checkDelete(String) checkDelete} method is
 *          invoked to check delete access if the file is opened with the
 *          {@code DELETE_ON_CLOSE} option.
 *
 * @see java.nio.channels.FileChannel#open(Path,Set,FileAttribute[])
 */
public static SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException {
    return provider(path).newByteChannel(path, options, attrs);
}