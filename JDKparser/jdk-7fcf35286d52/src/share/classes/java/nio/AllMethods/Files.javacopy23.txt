// -- Copying and moving files --
/**
 * Copy a file to a target file.
 *
 * <p> This method copies a file to the target file with the {@code
 * options} parameter specifying how the copy is performed. By default, the
 * copy fails if the target file already exists or is a symbolic link,
 * except if the source and target are the {@link #isSameFile same} file, in
 * which case the method completes without copying the file. File attributes
 * are not required to be copied to the target file. If symbolic links are
 * supported, and the file is a symbolic link, then the final target of the
 * link is copied. If the file is a directory then it creates an empty
 * directory in the target location (entries in the directory are not
 * copied). This method can be used with the {@link #walkFileTree
 * walkFileTree} method to copy a directory and all entries in the directory,
 * or an entire <i>file-tree</i> where required.
 *
 * <p> The {@code options} parameter may include any of the following:
 *
 * <table border=1 cellpadding=5 summary="">
 * <tr> <th>Option</th> <th>Description</th> </tr>
 * <tr>
 *   <td> {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} </td>
 *   <td> If the target file exists, then the target file is replaced if it
 *     is not a non-empty directory. If the target file exists and is a
 *     symbolic link, then the symbolic link itself, not the target of
 *     the link, is replaced. </td>
 * </tr>
 * <tr>
 *   <td> {@link StandardCopyOption#COPY_ATTRIBUTES COPY_ATTRIBUTES} </td>
 *   <td> Attempts to copy the file attributes associated with this file to
 *     the target file. The exact file attributes that are copied is platform
 *     and file system dependent and therefore unspecified. Minimally, the
 *     {@link BasicFileAttributes#lastModifiedTime last-modified-time} is
 *     copied to the target file if supported by both the source and target
 *     file stores. Copying of file timestamps may result in precision
 *     loss. </td>
 * </tr>
 * <tr>
 *   <td> {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} </td>
 *   <td> Symbolic links are not followed. If the file is a symbolic link,
 *     then the symbolic link itself, not the target of the link, is copied.
 *     It is implementation specific if file attributes can be copied to the
 *     new link. In other words, the {@code COPY_ATTRIBUTES} option may be
 *     ignored when copying a symbolic link. </td>
 * </tr>
 * </table>
 *
 * <p> An implementation of this interface may support additional
 * implementation specific options.
 *
 * <p> Copying a file is not an atomic operation. If an {@link IOException}
 * is thrown, then it is possible that the target file is incomplete or some
 * of its file attributes have not been copied from the source file. When
 * the {@code REPLACE_EXISTING} option is specified and the target file
 * exists, then the target file is replaced. The check for the existence of
 * the file and the creation of the new file may not be atomic with respect
 * to other file system activities.
 *
 * <p> <b>Usage Example:</b>
 * Suppose we want to copy a file into a directory, giving it the same file
 * name as the source file:
 * <pre>
 *     Path source = ...
 *     Path newdir = ...
 *     Files.copy(source, newdir.resolve(source.getFileName());
 * </pre>
 *
 * @param   source
 *          the path to the file to copy
 * @param   target
 *          the path to the target file (may be associated with a different
 *          provider to the source path)
 * @param   options
 *          options specifying how the copy should be done
 *
 * @return  the path to the target file
 *
 * @throws  UnsupportedOperationException
 *          if the array contains a copy option that is not supported
 * @throws  FileAlreadyExistsException
 *          if the target file exists but cannot be replaced because the
 *          {@code REPLACE_EXISTING} option is not specified <i>(optional
 *          specific exception)</i>
 * @throws  DirectoryNotEmptyException
 *          the {@code REPLACE_EXISTING} option is specified but the file
 *          cannot be replaced because it is a non-empty directory
 *          <i>(optional specific exception)</i>
 * @throws  IOException
 *          if an I/O error occurs
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkRead(String) checkRead}
 *          method is invoked to check read access to the source file, the
 *          {@link SecurityManager#checkWrite(String) checkWrite} is invoked
 *          to check write access to the target file. If a symbolic link is
 *          copied the security manager is invoked to check {@link
 *          LinkPermission}{@code ("symbolic")}.
 */
public static Path copy(Path source, Path target, CopyOption... options) throws IOException {
    FileSystemProvider provider = provider(source);
    if (provider(target) == provider) {
        // same provider
        provider.copy(source, target, options);
    } else {
        // different providers
        CopyMoveHelper.copyToForeignTarget(source, target, options);
    }
    return target;
}