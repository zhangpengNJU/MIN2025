/**
 * Resolves this field to provide a simpler alternative or a date.
 * <p>
 * This method is invoked during the resolve phase of parsing.
 * It is designed to allow application defined fields to be simplified into
 * more standard fields, such as those on {@code ChronoField}, or into a date.
 * <p>
 * Applications should not normally invoke this method directly.
 *
 * @implSpec
 * If an implementation represents a field that can be simplified, or
 * combined with others, then this method must be implemented.
 * <p>
 * The specified map contains the current state of the parse.
 * The map is mutable and must be mutated to resolve the field and
 * any related fields. This method will only be invoked during parsing
 * if the map contains this field, and implementations should therefore
 * assume this field is present.
 * <p>
 * Resolving a field will consist of looking at the value of this field,
 * and potentially other fields, and either updating the map with a
 * simpler value, such as a {@code ChronoField}, or returning a
 * complete {@code ChronoLocalDate}. If a resolve is successful,
 * the code must remove all the fields that were resolved from the map,
 * including this field.
 * <p>
 * For example, the {@code IsoFields} class contains the quarter-of-year
 * and day-of-quarter fields. The implementation of this method in that class
 * resolves the two fields plus the {@link ChronoField#YEAR YEAR} into a
 * complete {@code LocalDate}. The resolve method will remove all three
 * fields from the map before returning the {@code LocalDate}.
 * <p>
 * A partially complete temporal is used to allow the chronology and zone
 * to be queried. In general, only the chronology will be needed.
 * Querying items other than the zone or chronology is undefined and
 * must not be relied on.
 * The behavior of other methods such as {@code get}, {@code getLong},
 * {@code range} and {@code isSupported} is unpredictable and the results undefined.
 * <p>
 * If resolution should be possible, but the data is invalid, the resolver
 * style should be used to determine an appropriate level of leniency, which
 * may require throwing a {@code DateTimeException} or {@code ArithmeticException}.
 * If no resolution is possible, the resolve method must return null.
 * <p>
 * When resolving time fields, the map will be altered and null returned.
 * When resolving date fields, the date is normally returned from the method,
 * with the map altered to remove the resolved fields. However, it would also
 * be acceptable for the date fields to be resolved into other {@code ChronoField}
 * instances that can produce a date, such as {@code EPOCH_DAY}.
 * <p>
 * Not all {@code TemporalAccessor} implementations are accepted as return values.
 * Implementations that call this method must accept {@code ChronoLocalDate},
 * {@code ChronoLocalDateTime}, {@code ChronoZonedDateTime} and {@code LocalTime}.
 * <p>
 * The default implementation must return null.
 *
 * @param fieldValues  the map of fields to values, which can be updated, not null
 * @param partialTemporal  the partially complete temporal to query for zone and
 *  chronology; querying for other things is undefined and not recommended, not null
 * @param resolverStyle  the requested type of resolve, not null
 * @return the resolved temporal object; null if resolving only
 *  changed the map, or no resolve occurred
 * @throws ArithmeticException if numeric overflow occurs
 * @throws DateTimeException if resolving results in an error. This must not be thrown
 *  by querying a field on the temporal without first checking if it is supported
 */
default TemporalAccessor resolve(Map<TemporalField, Long> fieldValues, TemporalAccessor partialTemporal, ResolverStyle resolverStyle) {
    return null;
}