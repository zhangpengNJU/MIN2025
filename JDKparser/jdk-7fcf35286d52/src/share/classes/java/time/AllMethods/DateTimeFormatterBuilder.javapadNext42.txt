/**
 * Causes the next added printer/parser to pad to a fixed width.
 * <p>
 * This padding is intended for padding other than zero-padding.
 * Zero-padding should be achieved using the appendValue methods.
 * <p>
 * During formatting, the decorated element will be output and then padded
 * to the specified width. An exception will be thrown during formatting if
 * the pad width is exceeded.
 * <p>
 * During parsing, the padding and decorated element are parsed.
 * If parsing is lenient, then the pad width is treated as a maximum.
 * If parsing is case insensitive, then the pad character is matched ignoring case.
 * The padding is parsed greedily. Thus, if the decorated element starts with
 * the pad character, it will not be parsed.
 *
 * @param padWidth  the pad width, 1 or greater
 * @param padChar  the pad character
 * @return this, for chaining, not null
 * @throws IllegalArgumentException if pad width is too small
 */
public DateTimeFormatterBuilder padNext(int padWidth, char padChar) {
    if (padWidth < 1) {
        throw new IllegalArgumentException("The pad width must be at least one but was " + padWidth);
    }
    active.padNextWidth = padWidth;
    active.padNextChar = padChar;
    active.valueParserIndex = -1;
    return this;
}