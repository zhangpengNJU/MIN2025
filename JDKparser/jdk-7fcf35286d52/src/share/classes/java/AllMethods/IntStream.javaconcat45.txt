/**
 * Creates a lazily concatenated stream whose elements are all the
 * elements of the first stream followed by all the elements of the
 * second stream.  The resulting stream is ordered if both
 * of the input streams are ordered, and parallel if either of the input
 * streams is parallel.  When the resulting stream is closed, the close
 * handlers for both input streams are invoked.
 *
 * @implNote
 * Use caution when constructing streams from repeated concatenation.
 * Accessing an element of a deeply concatenated stream can result in deep
 * call chains, or even {@code StackOverflowException}.
 *
 * @param a the first stream
 * @param b the second stream
 * @return the concatenation of the two input streams
 */
public static IntStream concat(IntStream a, IntStream b) {
    Objects.requireNonNull(a);
    Objects.requireNonNull(b);
    Spliterator.OfInt split = new Streams.ConcatSpliterator.OfInt(a.spliterator(), b.spliterator());
    IntStream stream = StreamSupport.intStream(split, a.isParallel() || b.isParallel());
    return stream.onClose(Streams.composedClose(a, b));
}