/**
 * Returns an identity-based set view of the keys contained in this map.
 * The set is backed by the map, so changes to the map are reflected in
 * the set, and vice-versa.  If the map is modified while an iteration
 * over the set is in progress, the results of the iteration are
 * undefined.  The set supports element removal, which removes the
 * corresponding mapping from the map, via the <tt>Iterator.remove</tt>,
 * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt>, and
 * <tt>clear</tt> methods.  It does not support the <tt>add</tt> or
 * <tt>addAll</tt> methods.
 *
 * <p><b>While the object returned by this method implements the
 * <tt>Set</tt> interface, it does <i>not</i> obey <tt>Set's</tt> general
 * contract.  Like its backing map, the set returned by this method
 * defines element equality as reference-equality rather than
 * object-equality.  This affects the behavior of its <tt>contains</tt>,
 * <tt>remove</tt>, <tt>containsAll</tt>, <tt>equals</tt>, and
 * <tt>hashCode</tt> methods.</b>
 *
 * <p><b>The <tt>equals</tt> method of the returned set returns <tt>true</tt>
 * only if the specified object is a set containing exactly the same
 * object references as the returned set.  The symmetry and transitivity
 * requirements of the <tt>Object.equals</tt> contract may be violated if
 * the set returned by this method is compared to a normal set.  However,
 * the <tt>Object.equals</tt> contract is guaranteed to hold among sets
 * returned by this method.</b>
 *
 * <p>The <tt>hashCode</tt> method of the returned set returns the sum of
 * the <i>identity hashcodes</i> of the elements in the set, rather than
 * the sum of their hashcodes.  This is mandated by the change in the
 * semantics of the <tt>equals</tt> method, in order to enforce the
 * general contract of the <tt>Object.hashCode</tt> method among sets
 * returned by this method.
 *
 * @return an identity-based set view of the keys contained in this map
 * @see Object#equals(Object)
 * @see System#identityHashCode(Object)
 */
public Set<K> keySet() {
    Set<K> ks = keySet;
    if (ks == null) {
        ks = new KeySet();
        keySet = ks;
    }
    return ks;
}