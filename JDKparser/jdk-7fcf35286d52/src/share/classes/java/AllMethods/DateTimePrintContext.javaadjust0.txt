private static TemporalAccessor adjust(final TemporalAccessor temporal, DateTimeFormatter formatter) {
    // normal case first (early return is an optimization)
    Chronology overrideChrono = formatter.getChronology();
    ZoneId overrideZone = formatter.getZone();
    if (overrideChrono == null && overrideZone == null) {
        return temporal;
    }
    // ensure minimal change (early return is an optimization)
    Chronology temporalChrono = temporal.query(TemporalQueries.chronology());
    ZoneId temporalZone = temporal.query(TemporalQueries.zoneId());
    if (Objects.equals(overrideChrono, temporalChrono)) {
        overrideChrono = null;
    }
    if (Objects.equals(overrideZone, temporalZone)) {
        overrideZone = null;
    }
    if (overrideChrono == null && overrideZone == null) {
        return temporal;
    }
    // make adjustment
    final Chronology effectiveChrono = (overrideChrono != null ? overrideChrono : temporalChrono);
    if (overrideZone != null) {
        // if have zone and instant, calculation is simple, defaulting chrono if necessary
        if (temporal.isSupported(INSTANT_SECONDS)) {
            Chronology chrono = (effectiveChrono != null ? effectiveChrono : IsoChronology.INSTANCE);
            return chrono.zonedDateTime(Instant.from(temporal), overrideZone);
        }
        // block changing zone on OffsetTime, and similar problem cases
        if (overrideZone.normalized() instanceof ZoneOffset && temporal.isSupported(OFFSET_SECONDS) && temporal.get(OFFSET_SECONDS) != overrideZone.getRules().getOffset(Instant.EPOCH).getTotalSeconds()) {
            throw new DateTimeException("Unable to apply override zone '" + overrideZone + "' because the temporal object being formatted has a different offset but" + " does not represent an instant: " + temporal);
        }
    }
    final ZoneId effectiveZone = (overrideZone != null ? overrideZone : temporalZone);
    final ChronoLocalDate effectiveDate;
    if (overrideChrono != null) {
        if (temporal.isSupported(EPOCH_DAY)) {
            effectiveDate = effectiveChrono.date(temporal);
        } else {
            // check for date fields other than epoch-day, ignoring case of converting null to ISO
            if (!(overrideChrono == IsoChronology.INSTANCE && temporalChrono == null)) {
                for (ChronoField f : ChronoField.values()) {
                    if (f.isDateBased() && temporal.isSupported(f)) {
                        throw new DateTimeException("Unable to apply override chronology '" + overrideChrono + "' because the temporal object being formatted contains date fields but" + " does not represent a whole date: " + temporal);
                    }
                }
            }
            effectiveDate = null;
        }
    } else {
        effectiveDate = null;
    }
    // combine available data
    // this is a non-standard temporal that is almost a pure delegate
    // this better handles map-like underlying temporal instances
    return new TemporalAccessor() {

        @Override
        public boolean isSupported(TemporalField field) {
            if (effectiveDate != null && field.isDateBased()) {
                return effectiveDate.isSupported(field);
            }
            return temporal.isSupported(field);
        }

        @Override
        public ValueRange range(TemporalField field) {
            if (effectiveDate != null && field.isDateBased()) {
                return effectiveDate.range(field);
            }
            return temporal.range(field);
        }

        @Override
        public long getLong(TemporalField field) {
            if (effectiveDate != null && field.isDateBased()) {
                return effectiveDate.getLong(field);
            }
            return temporal.getLong(field);
        }

        @SuppressWarnings("unchecked")
        @Override
        public <R> R query(TemporalQuery<R> query) {
            if (query == TemporalQueries.chronology()) {
                return (R) effectiveChrono;
            }
            if (query == TemporalQueries.zoneId()) {
                return (R) effectiveZone;
            }
            if (query == TemporalQueries.precision()) {
                return temporal.query(query);
            }
            return query.queryFrom(this);
        }
    };
}