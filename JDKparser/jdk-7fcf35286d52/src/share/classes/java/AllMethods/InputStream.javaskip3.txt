/**
 * Skips over and discards <code>n</code> bytes of data from this input
 * stream. The <code>skip</code> method may, for a variety of reasons, end
 * up skipping over some smaller number of bytes, possibly <code>0</code>.
 * This may result from any of a number of conditions; reaching end of file
 * before <code>n</code> bytes have been skipped is only one possibility.
 * The actual number of bytes skipped is returned. If {@code n} is
 * negative, the {@code skip} method for class {@code InputStream} always
 * returns 0, and no bytes are skipped. Subclasses may handle the negative
 * value differently.
 *
 * <p> The <code>skip</code> method of this class creates a
 * byte array and then repeatedly reads into it until <code>n</code> bytes
 * have been read or the end of the stream has been reached. Subclasses are
 * encouraged to provide a more efficient implementation of this method.
 * For instance, the implementation may depend on the ability to seek.
 *
 * @param      n   the number of bytes to be skipped.
 * @return     the actual number of bytes skipped.
 * @exception  IOException  if the stream does not support seek,
 *                          or if some other I/O error occurs.
 */
public long skip(long n) throws IOException {
    long remaining = n;
    int nr;
    if (n <= 0) {
        return 0;
    }
    int size = (int) Math.min(MAX_SKIP_BUFFER_SIZE, remaining);
    byte[] skipBuffer = new byte[size];
    while (remaining > 0) {
        nr = read(skipBuffer, 0, (int) Math.min(size, remaining));
        if (nr < 0) {
            break;
        }
        remaining -= nr;
    }
    return n - remaining;
}