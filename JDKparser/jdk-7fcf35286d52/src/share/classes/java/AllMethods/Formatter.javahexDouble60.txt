// Method assumes that d > 0.
private String hexDouble(double d, int prec) {
    // Let Double.toHexString handle simple cases
    if (!Double.isFinite(d) || d == 0.0 || prec == 0 || prec >= 13)
        // remove "0x"
        return Double.toHexString(d).substring(2);
    else {
        assert (prec >= 1 && prec <= 12);
        int exponent = Math.getExponent(d);
        boolean subnormal = (exponent == DoubleConsts.MIN_EXPONENT - 1);
        // If this is subnormal input so normalize (could be faster to
        // do as integer operation).
        if (subnormal) {
            scaleUp = Math.scalb(1.0, 54);
            d *= scaleUp;
            // Calculate the exponent.  This is not just exponent + 54
            // since the former is not the normalized exponent.
            exponent = Math.getExponent(d);
            assert exponent >= DoubleConsts.MIN_EXPONENT && exponent <= DoubleConsts.MAX_EXPONENT : exponent;
        }
        int precision = 1 + prec * 4;
        int shiftDistance = DoubleConsts.SIGNIFICAND_WIDTH - precision;
        assert (shiftDistance >= 1 && shiftDistance < DoubleConsts.SIGNIFICAND_WIDTH);
        long doppel = Double.doubleToLongBits(d);
        // Deterime the number of bits to keep.
        long newSignif = (doppel & (DoubleConsts.EXP_BIT_MASK | DoubleConsts.SIGNIF_BIT_MASK)) >> shiftDistance;
        // Bits to round away.
        long roundingBits = doppel & ~(~0L << shiftDistance);
        // To decide how to round, look at the low-order bit of the
        // working significand, the highest order discarded bit (the
        // round bit) and whether any of the lower order discarded bits
        // are nonzero (the sticky bit).
        boolean leastZero = (newSignif & 0x1L) == 0L;
        boolean round = ((1L << (shiftDistance - 1)) & roundingBits) != 0L;
        boolean sticky = shiftDistance > 1 && (~(1L << (shiftDistance - 1)) & roundingBits) != 0;
        if ((leastZero && round && sticky) || (!leastZero && round)) {
            newSignif++;
        }
        long signBit = doppel & DoubleConsts.SIGN_BIT_MASK;
        newSignif = signBit | (newSignif << shiftDistance);
        double result = Double.longBitsToDouble(newSignif);
        if (Double.isInfinite(result)) {
            // Infinite result generated by rounding
            return "1.0p1024";
        } else {
            String res = Double.toHexString(result).substring(2);
            if (!subnormal)
                return res;
            else {
                // Create a normalized subnormal string.
                int idx = res.indexOf('p');
                if (idx == -1) {
                    // No 'p' character in hex string.
                    assert false;
                    return null;
                } else {
                    // Get exponent and append at the end.
                    String exp = res.substring(idx + 1);
                    int iexp = Integer.parseInt(exp) - 54;
                    return res.substring(0, idx) + "p" + Integer.toString(iexp);
                }
            }
        }
    }
}