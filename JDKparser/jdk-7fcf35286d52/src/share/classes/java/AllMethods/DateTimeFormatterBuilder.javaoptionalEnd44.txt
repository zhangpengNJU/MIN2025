/**
 * Ends an optional section.
 * <p>
 * The output of formatting can include optional sections, which may be nested.
 * An optional section is started by calling {@link #optionalStart()} and ended
 * using this method (or at the end of the builder).
 * <p>
 * Calling this method without having previously called {@code optionalStart}
 * will throw an exception.
 * Calling this method immediately after calling {@code optionalStart} has no effect
 * on the formatter other than ending the (empty) optional section.
 * <p>
 * All elements in the optional section are treated as optional.
 * During formatting, the section is only output if data is available in the
 * {@code TemporalAccessor} for all the elements in the section.
 * During parsing, the whole section may be missing from the parsed string.
 * <p>
 * For example, consider a builder setup as
 * {@code builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2).optionalEnd()}.
 * During formatting, the minute will only be output if its value can be obtained from the date-time.
 * During parsing, the input will be successfully parsed whether the minute is present or not.
 *
 * @return this, for chaining, not null
 * @throws IllegalStateException if there was no previous call to {@code optionalStart}
 */
public DateTimeFormatterBuilder optionalEnd() {
    if (active.parent == null) {
        throw new IllegalStateException("Cannot call optionalEnd() as there was no previous call to optionalStart()");
    }
    if (active.printerParsers.size() > 0) {
        CompositePrinterParser cpp = new CompositePrinterParser(active.printerParsers, active.optional);
        active = active.parent;
        appendInternal(cpp);
    } else {
        active = active.parent;
    }
    return this;
}