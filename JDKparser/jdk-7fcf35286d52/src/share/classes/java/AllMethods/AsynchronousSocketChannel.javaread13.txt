/**
 * Reads a sequence of bytes from this channel into a subsequence of the
 * given buffers. This operation, sometimes called a <em>scattering read</em>,
 * is often useful when implementing network protocols that group data into
 * segments consisting of one or more fixed-length headers followed by a
 * variable-length body. The {@code handler} parameter is a completion
 * handler that is invoked when the read operation completes (or fails). The
 * result passed to the completion handler is the number of bytes read or
 * {@code -1} if no bytes could be read because the channel has reached
 * end-of-stream.
 *
 * <p> This method initiates a read of up to <i>r</i> bytes from this channel,
 * where <i>r</i> is the total number of bytes remaining in the specified
 * subsequence of the given buffer array, that is,
 *
 * <blockquote><pre>
 * dsts[offset].remaining()
 *     + dsts[offset+1].remaining()
 *     + ... + dsts[offset+length-1].remaining()</pre></blockquote>
 *
 * at the moment that the read is attempted.
 *
 * <p> Suppose that a byte sequence of length <i>n</i> is read, where
 * <tt>0</tt>&nbsp;<tt>&lt;</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>.
 * Up to the first <tt>dsts[offset].remaining()</tt> bytes of this sequence
 * are transferred into buffer <tt>dsts[offset]</tt>, up to the next
 * <tt>dsts[offset+1].remaining()</tt> bytes are transferred into buffer
 * <tt>dsts[offset+1]</tt>, and so forth, until the entire byte sequence
 * is transferred into the given buffers.  As many bytes as possible are
 * transferred into each buffer, hence the final position of each updated
 * buffer, except the last updated buffer, is guaranteed to be equal to
 * that buffer's limit. The underlying operating system may impose a limit
 * on the number of buffers that may be used in an I/O operation. Where the
 * number of buffers (with bytes remaining), exceeds this limit, then the
 * I/O operation is performed with the maximum number of buffers allowed by
 * the operating system.
 *
 * <p> If a timeout is specified and the timeout elapses before the operation
 * completes then it completes with the exception {@link
 * InterruptedByTimeoutException}. Where a timeout occurs, and the
 * implementation cannot guarantee that bytes have not been read, or will not
 * be read from the channel into the given buffers, then further attempts to
 * read from the channel will cause an unspecific runtime exception to be
 * thrown.
 *
 * @param   <A>
 *          The type of the attachment
 * @param   dsts
 *          The buffers into which bytes are to be transferred
 * @param   offset
 *          The offset within the buffer array of the first buffer into which
 *          bytes are to be transferred; must be non-negative and no larger than
 *          {@code dsts.length}
 * @param   length
 *          The maximum number of buffers to be accessed; must be non-negative
 *          and no larger than {@code dsts.length - offset}
 * @param   timeout
 *          The maximum time for the I/O operation to complete
 * @param   unit
 *          The time unit of the {@code timeout} argument
 * @param   attachment
 *          The object to attach to the I/O operation; can be {@code null}
 * @param   handler
 *          The handler for consuming the result
 *
 * @throws  IndexOutOfBoundsException
 *          If the pre-conditions for the {@code offset}  and {@code length}
 *          parameter aren't met
 * @throws  IllegalArgumentException
 *          If the buffer is read-only
 * @throws  ReadPendingException
 *          If a read operation is already in progress on this channel
 * @throws  NotYetConnectedException
 *          If this channel is not yet connected
 * @throws  ShutdownChannelGroupException
 *          If the channel group has terminated
 */
public abstract <A> void read(ByteBuffer[] dsts, int offset, int length, long timeout, TimeUnit unit, A attachment, CompletionHandler<Long, ? super A> handler);