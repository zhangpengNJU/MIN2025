// / method handle modification (creation from other method handles)
/**
 * Produces a method handle which adapts the type of the
 * given method handle to a new type by pairwise argument and return type conversion.
 * The original type and new type must have the same number of arguments.
 * The resulting method handle is guaranteed to report a type
 * which is equal to the desired new type.
 * <p>
 * If the original type and new type are equal, returns target.
 * <p>
 * The same conversions are allowed as for {@link MethodHandle#asType MethodHandle.asType},
 * and some additional conversions are also applied if those conversions fail.
 * Given types <em>T0</em>, <em>T1</em>, one of the following conversions is applied
 * if possible, before or instead of any conversions done by {@code asType}:
 * <ul>
 * <li>If <em>T0</em> and <em>T1</em> are references, and <em>T1</em> is an interface type,
 *     then the value of type <em>T0</em> is passed as a <em>T1</em> without a cast.
 *     (This treatment of interfaces follows the usage of the bytecode verifier.)
 * <li>If <em>T0</em> is boolean and <em>T1</em> is another primitive,
 *     the boolean is converted to a byte value, 1 for true, 0 for false.
 *     (This treatment follows the usage of the bytecode verifier.)
 * <li>If <em>T1</em> is boolean and <em>T0</em> is another primitive,
 *     <em>T0</em> is converted to byte via Java casting conversion (JLS 5.5),
 *     and the low order bit of the result is tested, as if by {@code (x & 1) != 0}.
 * <li>If <em>T0</em> and <em>T1</em> are primitives other than boolean,
 *     then a Java casting conversion (JLS 5.5) is applied.
 *     (Specifically, <em>T0</em> will convert to <em>T1</em> by
 *     widening and/or narrowing.)
 * <li>If <em>T0</em> is a reference and <em>T1</em> a primitive, an unboxing
 *     conversion will be applied at runtime, possibly followed
 *     by a Java casting conversion (JLS 5.5) on the primitive value,
 *     possibly followed by a conversion from byte to boolean by testing
 *     the low-order bit.
 * <li>If <em>T0</em> is a reference and <em>T1</em> a primitive,
 *     and if the reference is null at runtime, a zero value is introduced.
 * </ul>
 * @param target the method handle to invoke after arguments are retyped
 * @param newType the expected type of the new method handle
 * @return a method handle which delegates to the target after performing
 *           any necessary argument conversions, and arranges for any
 *           necessary return value conversions
 * @throws NullPointerException if either argument is null
 * @throws WrongMethodTypeException if the conversion cannot be made
 * @see MethodHandle#asType
 */
public static MethodHandle explicitCastArguments(MethodHandle target, MethodType newType) {
    explicitCastArgumentsChecks(target, newType);
    // use the asTypeCache when possible:
    MethodType oldType = target.type();
    if (oldType == newType)
        return target;
    if (oldType.explicitCastEquivalentToAsType(newType)) {
        return target.asFixedArity().asType(newType);
    }
    return MethodHandleImpl.makePairwiseConvert(target, newType, false);
}