/**
 * Finds or creates an instance of a method type, given the spelling of its bytecode descriptor.
 * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
 * Any class or interface name embedded in the descriptor string
 * will be resolved by calling {@link ClassLoader#loadClass(java.lang.String)}
 * on the given loader (or if it is null, on the system class loader).
 * <p>
 * Note that it is possible to encounter method types which cannot be
 * constructed by this method, because their component types are
 * not all reachable from a common class loader.
 * <p>
 * This method is included for the benefit of applications that must
 * generate bytecodes that process method handles and {@code invokedynamic}.
 * @param descriptor a bytecode-level type descriptor string "(T...)T"
 * @param loader the class loader in which to look up the types
 * @return a method type matching the bytecode-level type descriptor
 * @throws NullPointerException if the string is null
 * @throws IllegalArgumentException if the string is not well-formed
 * @throws TypeNotPresentException if a named type cannot be found
 */
public static MethodType fromMethodDescriptorString(String descriptor, ClassLoader loader) throws IllegalArgumentException, TypeNotPresentException {
    if (// also generates NPE if needed
    !descriptor.startsWith("(") || descriptor.indexOf(')') < 0 || descriptor.indexOf('.') >= 0)
        throw newIllegalArgumentException("not a method descriptor: " + descriptor);
    List<Class<?>> types = BytecodeDescriptor.parseMethod(descriptor, loader);
    Class<?> rtype = types.remove(types.size() - 1);
    checkSlotCount(types.size());
    Class<?>[] ptypes = listToArray(types);
    return makeImpl(rtype, ptypes, true);
}