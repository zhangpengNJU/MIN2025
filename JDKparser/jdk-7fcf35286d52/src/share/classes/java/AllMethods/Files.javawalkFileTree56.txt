// -- Recursive operations --
/**
 * Walks a file tree.
 *
 * <p> This method walks a file tree rooted at a given starting file. The
 * file tree traversal is <em>depth-first</em> with the given {@link
 * FileVisitor} invoked for each file encountered. File tree traversal
 * completes when all accessible files in the tree have been visited, or a
 * visit method returns a result of {@link FileVisitResult#TERMINATE
 * TERMINATE}. Where a visit method terminates due an {@code IOException},
 * an uncaught error, or runtime exception, then the traversal is terminated
 * and the error or exception is propagated to the caller of this method.
 *
 * <p> For each file encountered this method attempts to read its {@link
 * java.nio.file.attribute.BasicFileAttributes}. If the file is not a
 * directory then the {@link FileVisitor#visitFile visitFile} method is
 * invoked with the file attributes. If the file attributes cannot be read,
 * due to an I/O exception, then the {@link FileVisitor#visitFileFailed
 * visitFileFailed} method is invoked with the I/O exception.
 *
 * <p> Where the file is a directory, and the directory could not be opened,
 * then the {@code visitFileFailed} method is invoked with the I/O exception,
 * after which, the file tree walk continues, by default, at the next
 * <em>sibling</em> of the directory.
 *
 * <p> Where the directory is opened successfully, then the entries in the
 * directory, and their <em>descendants</em> are visited. When all entries
 * have been visited, or an I/O error occurs during iteration of the
 * directory, then the directory is closed and the visitor's {@link
 * FileVisitor#postVisitDirectory postVisitDirectory} method is invoked.
 * The file tree walk then continues, by default, at the next <em>sibling</em>
 * of the directory.
 *
 * <p> By default, symbolic links are not automatically followed by this
 * method. If the {@code options} parameter contains the {@link
 * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are
 * followed. When following links, and the attributes of the target cannot
 * be read, then this method attempts to get the {@code BasicFileAttributes}
 * of the link. If they can be read then the {@code visitFile} method is
 * invoked with the attributes of the link (otherwise the {@code visitFileFailed}
 * method is invoked as specified above).
 *
 * <p> If the {@code options} parameter contains the {@link
 * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then this method keeps
 * track of directories visited so that cycles can be detected. A cycle
 * arises when there is an entry in a directory that is an ancestor of the
 * directory. Cycle detection is done by recording the {@link
 * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,
 * or if file keys are not available, by invoking the {@link #isSameFile
 * isSameFile} method to test if a directory is the same file as an
 * ancestor. When a cycle is detected it is treated as an I/O error, and the
 * {@link FileVisitor#visitFileFailed visitFileFailed} method is invoked with
 * an instance of {@link FileSystemLoopException}.
 *
 * <p> The {@code maxDepth} parameter is the maximum number of levels of
 * directories to visit. A value of {@code 0} means that only the starting
 * file is visited, unless denied by the security manager. A value of
 * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all
 * levels should be visited. The {@code visitFile} method is invoked for all
 * files, including directories, encountered at {@code maxDepth}, unless the
 * basic file attributes cannot be read, in which case the {@code
 * visitFileFailed} method is invoked.
 *
 * <p> If a visitor returns a result of {@code null} then {@code
 * NullPointerException} is thrown.
 *
 * <p> When a security manager is installed and it denies access to a file
 * (or directory), then it is ignored and the visitor is not invoked for
 * that file (or directory).
 *
 * @param   start
 *          the starting file
 * @param   options
 *          options to configure the traversal
 * @param   maxDepth
 *          the maximum number of directory levels to visit
 * @param   visitor
 *          the file visitor to invoke for each file
 *
 * @return  the starting file
 *
 * @throws  IllegalArgumentException
 *          if the {@code maxDepth} parameter is negative
 * @throws  SecurityException
 *          If the security manager denies access to the starting file.
 *          In the case of the default provider, the {@link
 *          SecurityManager#checkRead(String) checkRead} method is invoked
 *          to check read access to the directory.
 * @throws  IOException
 *          if an I/O error is thrown by a visitor method
 */
public static Path walkFileTree(Path start, Set<FileVisitOption> options, int maxDepth, FileVisitor<? super Path> visitor) throws IOException {
    /**
     * Create a FileTreeWalker to walk the file tree, invoking the visitor
     * for each event.
     */
    try (FileTreeWalker walker = new FileTreeWalker(options, maxDepth)) {
        FileTreeWalker.Event ev = walker.walk(start);
        do {
            FileVisitResult result;
            switch(ev.type()) {
                case ENTRY:
                    IOException ioe = ev.ioeException();
                    if (ioe == null) {
                        assert ev.attributes() != null;
                        result = visitor.visitFile(ev.file(), ev.attributes());
                    } else {
                        result = visitor.visitFileFailed(ev.file(), ioe);
                    }
                    break;
                case START_DIRECTORY:
                    result = visitor.preVisitDirectory(ev.file(), ev.attributes());
                    // if SKIP_SIBLINGS and SKIP_SUBTREE is returned then
                    // there shouldn't be any more events for the current
                    // directory.
                    if (result == FileVisitResult.SKIP_SUBTREE || result == FileVisitResult.SKIP_SIBLINGS)
                        walker.pop();
                    break;
                case END_DIRECTORY:
                    result = visitor.postVisitDirectory(ev.file(), ev.ioeException());
                    // SKIP_SIBLINGS is a no-op for postVisitDirectory
                    if (result == FileVisitResult.SKIP_SIBLINGS)
                        result = FileVisitResult.CONTINUE;
                    break;
                default:
                    throw new AssertionError("Should not get here");
            }
            if (Objects.requireNonNull(result) != FileVisitResult.CONTINUE) {
                if (result == FileVisitResult.TERMINATE) {
                    break;
                } else if (result == FileVisitResult.SKIP_SIBLINGS) {
                    walker.skipRemainingSiblings();
                }
            }
            ev = walker.next();
        } while (ev != null);
    }
    return start;
}