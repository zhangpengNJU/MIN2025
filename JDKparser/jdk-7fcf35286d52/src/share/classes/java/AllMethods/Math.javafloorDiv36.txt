/**
 * Returns the largest (closest to positive infinity)
 * {@code long} value that is less than or equal to the algebraic quotient.
 * There is one special case, if the dividend is the
 * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is {@code -1},
 * then integer overflow occurs and
 * the result is equal to the {@code Long.MIN_VALUE}.
 * <p>
 * Normal integer division operates under the round to zero rounding mode
 * (truncation).  This operation instead acts under the round toward
 * negative infinity (floor) rounding mode.
 * The floor rounding mode gives different results than truncation
 * when the exact result is negative.
 * <p>
 * For examples, see {@link #floorDiv(int, int)}.
 *
 * @param x the dividend
 * @param y the divisor
 * @return the largest (closest to positive infinity)
 * {@code long} value that is less than or equal to the algebraic quotient.
 * @throws ArithmeticException if the divisor {@code y} is zero
 * @see #floorMod(long, long)
 * @see #floor(double)
 * @since 1.8
 */
public static long floorDiv(long x, long y) {
    long r = x / y;
    // if the signs are different and modulo not zero, round down
    if ((x ^ y) < 0 && (r * y != x)) {
        r--;
    }
    return r;
}