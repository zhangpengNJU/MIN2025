/**
 * Verifies that this certificate was signed using the
 * private key that corresponds to the specified public key.
 * This method uses the signature verification engine
 * supplied by the specified provider. Note that the specified
 * Provider object does not have to be registered in the provider list.
 *
 * This method was added to version 1.8 of the Java Platform Standard
 * Edition. In order to maintain backwards compatibility with existing
 * service providers, this method is not {@code abstract}
 * and it provides a default implementation.
 *
 * @param key the PublicKey used to carry out the verification.
 * @param sigProvider the signature provider.
 *
 * @exception NoSuchAlgorithmException on unsupported signature
 * algorithms.
 * @exception InvalidKeyException on incorrect key.
 * @exception SignatureException on signature errors.
 * @exception CertificateException on encoding errors.
 * @exception UnsupportedOperationException if the method is not supported
 * @since 1.8
 */
public void verify(PublicKey key, Provider sigProvider) throws CertificateException, NoSuchAlgorithmException, InvalidKeyException, SignatureException {
    String sigName = getSigAlgName();
    Signature sig = (sigProvider == null) ? Signature.getInstance(sigName) : Signature.getInstance(sigName, sigProvider);
    try {
        SignatureUtil.initVerifyWithParam(sig, key, SignatureUtil.getParamSpec(sigName, getSigAlgParams()));
    } catch (ProviderException e) {
        throw new CertificateException(e.getMessage(), e.getCause());
    } catch (InvalidAlgorithmParameterException e) {
        throw new CertificateException(e);
    }
    byte[] tbsCert = getTBSCertificate();
    sig.update(tbsCert, 0, tbsCert.length);
    if (sig.verify(getSignature()) == false) {
        throw new SignatureException("Signature does not match.");
    }
}