/**
 * Returns a concurrent {@code Collector} that accumulates elements into a
 * {@code ConcurrentMap} whose keys and values are the result of applying
 * the provided mapping functions to the input elements.
 *
 * <p>If the mapped keys contains duplicates (according to {@link Object#equals(Object)}),
 * the value mapping function is applied to each equal element, and the
 * results are merged using the provided merging function.  The
 * {@code ConcurrentMap} is created by a provided supplier function.
 *
 * <p>This is a {@link Collector.Characteristics#CONCURRENT concurrent} and
 * {@link Collector.Characteristics#UNORDERED unordered} Collector.
 *
 * @param <T> the type of the input elements
 * @param <K> the output type of the key mapping function
 * @param <U> the output type of the value mapping function
 * @param <M> the type of the resulting {@code ConcurrentMap}
 * @param keyMapper a mapping function to produce keys
 * @param valueMapper a mapping function to produce values
 * @param mergeFunction a merge function, used to resolve collisions between
 *                      values associated with the same key, as supplied
 *                      to {@link Map#merge(Object, Object, BiFunction)}
 * @param mapSupplier a function which returns a new, empty {@code Map} into
 *                    which the results will be inserted
 * @return a concurrent, unordered {@code Collector} which collects elements into a
 * {@code ConcurrentMap} whose keys are the result of applying a key mapping
 * function to the input elements, and whose values are the result of
 * applying a value mapping function to all input elements equal to the key
 * and combining them using the merge function
 *
 * @see #toConcurrentMap(Function, Function)
 * @see #toConcurrentMap(Function, Function, BinaryOperator)
 * @see #toMap(Function, Function, BinaryOperator, Supplier)
 */
public static <T, K, U, M extends ConcurrentMap<K, U>> Collector<T, ?, M> toConcurrentMap(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper, BinaryOperator<U> mergeFunction, Supplier<M> mapSupplier) {
    BiConsumer<M, T> accumulator = (map, element) -> map.merge(keyMapper.apply(element), valueMapper.apply(element), mergeFunction);
    return new CollectorImpl<>(mapSupplier, accumulator, mapMerger(mergeFunction), CH_CONCURRENT_ID);
}