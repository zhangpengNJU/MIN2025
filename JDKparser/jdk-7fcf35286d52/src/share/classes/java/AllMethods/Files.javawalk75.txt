/**
 * Return a {@code Stream} that is lazily populated with {@code
 * Path} by walking the file tree rooted at a given starting file.  The
 * file tree is traversed <em>depth-first</em>, the elements in the stream
 * are {@link Path} objects that are obtained as if by {@link
 * Path#resolve(Path) resolving} the relative path against {@code start}.
 *
 * <p> The {@code stream} walks the file tree as elements are consumed.
 * The {@code Stream} returned is guaranteed to have at least one
 * element, the starting file itself. For each file visited, the stream
 * attempts to read its {@link BasicFileAttributes}. If the file is a
 * directory and can be opened successfully, entries in the directory, and
 * their <em>descendants</em> will follow the directory in the stream as
 * they are encountered. When all entries have been visited, then the
 * directory is closed. The file tree walk then continues at the next
 * <em>sibling</em> of the directory.
 *
 * <p> The stream is <i>weakly consistent</i>. It does not freeze the
 * file tree while iterating, so it may (or may not) reflect updates to
 * the file tree that occur after returned from this method.
 *
 * <p> By default, symbolic links are not automatically followed by this
 * method. If the {@code options} parameter contains the {@link
 * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are
 * followed. When following links, and the attributes of the target cannot
 * be read, then this method attempts to get the {@code BasicFileAttributes}
 * of the link.
 *
 * <p> If the {@code options} parameter contains the {@link
 * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then the stream keeps
 * track of directories visited so that cycles can be detected. A cycle
 * arises when there is an entry in a directory that is an ancestor of the
 * directory. Cycle detection is done by recording the {@link
 * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,
 * or if file keys are not available, by invoking the {@link #isSameFile
 * isSameFile} method to test if a directory is the same file as an
 * ancestor. When a cycle is detected it is treated as an I/O error with
 * an instance of {@link FileSystemLoopException}.
 *
 * <p> The {@code maxDepth} parameter is the maximum number of levels of
 * directories to visit. A value of {@code 0} means that only the starting
 * file is visited, unless denied by the security manager. A value of
 * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all
 * levels should be visited.
 *
 * <p> When a security manager is installed and it denies access to a file
 * (or directory), then it is ignored and not included in the stream.
 *
 * <p> The returned stream encapsulates one or more {@link DirectoryStream}s.
 * If timely disposal of file system resources is required, the
 * {@code try}-with-resources construct should be used to ensure that the
 * stream's {@link Stream#close close} method is invoked after the stream
 * operations are completed.  Operating on a closed stream will result in an
 * {@link java.lang.IllegalStateException}.
 *
 * <p> If an {@link IOException} is thrown when accessing the directory
 * after this method has returned, it is wrapped in an {@link
 * UncheckedIOException} which will be thrown from the method that caused
 * the access to take place.
 *
 * @param   start
 *          the starting file
 * @param   maxDepth
 *          the maximum number of directory levels to visit
 * @param   options
 *          options to configure the traversal
 *
 * @return  the {@link Stream} of {@link Path}
 *
 * @throws  IllegalArgumentException
 *          if the {@code maxDepth} parameter is negative
 * @throws  SecurityException
 *          If the security manager denies access to the starting file.
 *          In the case of the default provider, the {@link
 *          SecurityManager#checkRead(String) checkRead} method is invoked
 *          to check read access to the directory.
 * @throws  IOException
 *          if an I/O error is thrown when accessing the starting file.
 * @since   1.8
 */
public static Stream<Path> walk(Path start, int maxDepth, FileVisitOption... options) throws IOException {
    FileTreeIterator iterator = new FileTreeIterator(start, maxDepth, options);
    try {
        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT), false).onClose(iterator::close).map(entry -> entry.file());
    } catch (Error | RuntimeException e) {
        iterator.close();
        throw e;
    }
}