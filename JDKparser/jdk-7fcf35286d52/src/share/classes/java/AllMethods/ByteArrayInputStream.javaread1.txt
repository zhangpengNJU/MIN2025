/**
 * Reads up to <code>len</code> bytes of data into an array of bytes
 * from this input stream.
 * If <code>pos</code> equals <code>count</code>,
 * then <code>-1</code> is returned to indicate
 * end of file. Otherwise, the  number <code>k</code>
 * of bytes read is equal to the smaller of
 * <code>len</code> and <code>count-pos</code>.
 * If <code>k</code> is positive, then bytes
 * <code>buf[pos]</code> through <code>buf[pos+k-1]</code>
 * are copied into <code>b[off]</code>  through
 * <code>b[off+k-1]</code> in the manner performed
 * by <code>System.arraycopy</code>. The
 * value <code>k</code> is added into <code>pos</code>
 * and <code>k</code> is returned.
 * <p>
 * This <code>read</code> method cannot block.
 *
 * @param   b     the buffer into which the data is read.
 * @param   off   the start offset in the destination array <code>b</code>
 * @param   len   the maximum number of bytes read.
 * @return  the total number of bytes read into the buffer, or
 *          <code>-1</code> if there is no more data because the end of
 *          the stream has been reached.
 * @exception  NullPointerException If <code>b</code> is <code>null</code>.
 * @exception  IndexOutOfBoundsException If <code>off</code> is negative,
 * <code>len</code> is negative, or <code>len</code> is greater than
 * <code>b.length - off</code>
 */
public synchronized int read(byte[] b, int off, int len) {
    if (b == null) {
        throw new NullPointerException();
    } else if (off < 0 || len < 0 || len > b.length - off) {
        throw new IndexOutOfBoundsException();
    }
    if (pos >= count) {
        return -1;
    }
    int avail = count - pos;
    if (len > avail) {
        len = avail;
    }
    if (len <= 0) {
        return 0;
    }
    System.arraycopy(buf, pos, b, off, len);
    pos += len;
    return len;
}