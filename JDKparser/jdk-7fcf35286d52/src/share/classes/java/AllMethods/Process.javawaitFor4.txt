/**
 * Causes the current thread to wait, if necessary, until the
 * subprocess represented by this {@code Process} object has
 * terminated, or the specified waiting time elapses.
 *
 * <p>If the subprocess has already terminated then this method returns
 * immediately with the value {@code true}.  If the process has not
 * terminated and the timeout value is less than, or equal to, zero, then
 * this method returns immediately with the value {@code false}.
 *
 * <p>The default implementation of this methods polls the {@code exitValue}
 * to check if the process has terminated. Concrete implementations of this
 * class are strongly encouraged to override this method with a more
 * efficient implementation.
 *
 * @param timeout the maximum time to wait
 * @param unit the time unit of the {@code timeout} argument
 * @return {@code true} if the subprocess has exited and {@code false} if
 *         the waiting time elapsed before the subprocess has exited.
 * @throws InterruptedException if the current thread is interrupted
 *         while waiting.
 * @throws NullPointerException if unit is null
 * @since 1.8
 */
public boolean waitFor(long timeout, TimeUnit unit) throws InterruptedException {
    long startTime = System.nanoTime();
    long rem = unit.toNanos(timeout);
    do {
        try {
            exitValue();
            return true;
        } catch (IllegalThreadStateException ex) {
            if (rem > 0)
                Thread.sleep(Math.min(TimeUnit.NANOSECONDS.toMillis(rem) + 1, 100));
        }
        rem = unit.toNanos(timeout) - (System.nanoTime() - startTime);
    } while (rem > 0);
    return false;
}