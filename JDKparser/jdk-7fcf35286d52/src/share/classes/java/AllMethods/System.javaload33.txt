/**
 * Loads the native library specified by the filename argument.  The filename
 * argument must be an absolute path name.
 *
 * If the filename argument, when stripped of any platform-specific library
 * prefix, path, and file extension, indicates a library whose name is,
 * for example, L, and a native library called L is statically linked
 * with the VM, then the JNI_OnLoad_L function exported by the library
 * is invoked rather than attempting to load a dynamic library.
 * A filename matching the argument does not have to exist in the
 * file system.
 * See the JNI Specification for more details.
 *
 * Otherwise, the filename argument is mapped to a native library image in
 * an implementation-dependent manner.
 *
 * <p>
 * The call <code>System.load(name)</code> is effectively equivalent
 * to the call:
 * <blockquote><pre>
 * Runtime.getRuntime().load(name)
 * </pre></blockquote>
 *
 * @param      filename   the file to load.
 * @exception  SecurityException  if a security manager exists and its
 *             <code>checkLink</code> method doesn't allow
 *             loading of the specified dynamic library
 * @exception  UnsatisfiedLinkError  if either the filename is not an
 *             absolute path name, the native library is not statically
 *             linked with the VM, or the library cannot be mapped to
 *             a native library image by the host system.
 * @exception  NullPointerException if <code>filename</code> is
 *             <code>null</code>
 * @see        java.lang.Runtime#load(java.lang.String)
 * @see        java.lang.SecurityManager#checkLink(java.lang.String)
 */
@CallerSensitive
public static void load(String filename) {
    Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);
}