// -----------------------------------------------------------------------
/**
 * Obtains a {@code Duration} representing the duration between two temporal objects.
 * <p>
 * This calculates the duration between two temporal objects. If the objects
 * are of different types, then the duration is calculated based on the type
 * of the first object. For example, if the first argument is a {@code LocalTime}
 * then the second argument is converted to a {@code LocalTime}.
 * <p>
 * The specified temporal objects must support the {@link ChronoUnit#SECONDS SECONDS} unit.
 * For full accuracy, either the {@link ChronoUnit#NANOS NANOS} unit or the
 * {@link ChronoField#NANO_OF_SECOND NANO_OF_SECOND} field should be supported.
 * <p>
 * The result of this method can be a negative period if the end is before the start.
 * To guarantee to obtain a positive duration call {@link #abs()} on the result.
 *
 * @param startInclusive  the start instant, inclusive, not null
 * @param endExclusive  the end instant, exclusive, not null
 * @return a {@code Duration}, not null
 * @throws DateTimeException if the seconds between the temporals cannot be obtained
 * @throws ArithmeticException if the calculation exceeds the capacity of {@code Duration}
 */
public static Duration between(Temporal startInclusive, Temporal endExclusive) {
    try {
        return ofNanos(startInclusive.until(endExclusive, NANOS));
    } catch (DateTimeException | ArithmeticException ex) {
        long secs = startInclusive.until(endExclusive, SECONDS);
        long nanos;
        try {
            nanos = endExclusive.getLong(NANO_OF_SECOND) - startInclusive.getLong(NANO_OF_SECOND);
            if (secs > 0 && nanos < 0) {
                secs++;
            } else if (secs < 0 && nanos > 0) {
                secs--;
            }
        } catch (DateTimeException ex2) {
            nanos = 0;
        }
        return ofSeconds(secs, nanos);
    }
}