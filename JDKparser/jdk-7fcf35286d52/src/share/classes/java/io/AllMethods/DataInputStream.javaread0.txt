/**
 * Reads some number of bytes from the contained input stream and
 * stores them into the buffer array <code>b</code>. The number of
 * bytes actually read is returned as an integer. This method blocks
 * until input data is available, end of file is detected, or an
 * exception is thrown.
 *
 * <p>If <code>b</code> is null, a <code>NullPointerException</code> is
 * thrown. If the length of <code>b</code> is zero, then no bytes are
 * read and <code>0</code> is returned; otherwise, there is an attempt
 * to read at least one byte. If no byte is available because the
 * stream is at end of file, the value <code>-1</code> is returned;
 * otherwise, at least one byte is read and stored into <code>b</code>.
 *
 * <p>The first byte read is stored into element <code>b[0]</code>, the
 * next one into <code>b[1]</code>, and so on. The number of bytes read
 * is, at most, equal to the length of <code>b</code>. Let <code>k</code>
 * be the number of bytes actually read; these bytes will be stored in
 * elements <code>b[0]</code> through <code>b[k-1]</code>, leaving
 * elements <code>b[k]</code> through <code>b[b.length-1]</code>
 * unaffected.
 *
 * <p>The <code>read(b)</code> method has the same effect as:
 * <blockquote><pre>
 * read(b, 0, b.length)
 * </pre></blockquote>
 *
 * @param      b   the buffer into which the data is read.
 * @return     the total number of bytes read into the buffer, or
 *             <code>-1</code> if there is no more data because the end
 *             of the stream has been reached.
 * @exception  IOException if the first byte cannot be read for any reason
 * other than end of file, the stream has been closed and the underlying
 * input stream does not support reading after close, or another I/O
 * error occurs.
 * @see        java.io.FilterInputStream#in
 * @see        java.io.InputStream#read(byte[], int, int)
 */
public final int read(byte[] b) throws IOException {
    return in.read(b, 0, b.length);
}