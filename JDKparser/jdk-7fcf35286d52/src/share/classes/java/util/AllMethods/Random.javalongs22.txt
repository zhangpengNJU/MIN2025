/**
 * Returns an effectively unlimited stream of pseudorandom {@code
 * long} values, each conforming to the given origin (inclusive) and bound
 * (exclusive).
 *
 * <p>A pseudorandom {@code long} value is generated as if it's the result
 * of calling the following method with the origin and bound:
 * <pre> {@code
 * long nextLong(long origin, long bound) {
 *   long r = nextLong();
 *   long n = bound - origin, m = n - 1;
 *   if ((n & m) == 0L)  // power of two
 *     r = (r & m) + origin;
 *   else if (n > 0L) {  // reject over-represented candidates
 *     for (long u = r >>> 1;            // ensure nonnegative
 *          u + m - (r = u % n) < 0L;    // rejection check
 *          u = nextLong() >>> 1) // retry
 *         ;
 *     r += origin;
 *   }
 *   else {              // range not representable as long
 *     while (r < origin || r >= bound)
 *       r = nextLong();
 *   }
 *   return r;
 * }}</pre>
 *
 * @implNote This method is implemented to be equivalent to {@code
 * longs(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.
 *
 * @param randomNumberOrigin the origin (inclusive) of each random value
 * @param randomNumberBound the bound (exclusive) of each random value
 * @return a stream of pseudorandom {@code long} values,
 *         each with the given origin (inclusive) and bound (exclusive)
 * @throws IllegalArgumentException if {@code randomNumberOrigin}
 *         is greater than or equal to {@code randomNumberBound}
 * @since 1.8
 */
public LongStream longs(long randomNumberOrigin, long randomNumberBound) {
    if (randomNumberOrigin >= randomNumberBound)
        throw new IllegalArgumentException(BadRange);
    return StreamSupport.longStream(new RandomLongsSpliterator(this, 0L, Long.MAX_VALUE, randomNumberOrigin, randomNumberBound), false);
}