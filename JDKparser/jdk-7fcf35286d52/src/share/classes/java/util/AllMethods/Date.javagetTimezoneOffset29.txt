/**
 * Returns the offset, measured in minutes, for the local time zone
 * relative to UTC that is appropriate for the time represented by
 * this <code>Date</code> object.
 * <p>
 * For example, in Massachusetts, five time zones west of Greenwich:
 * <blockquote><pre>
 * new Date(96, 1, 14).getTimezoneOffset() returns 300</pre></blockquote>
 * because on February 14, 1996, standard time (Eastern Standard Time)
 * is in use, which is offset five hours from UTC; but:
 * <blockquote><pre>
 * new Date(96, 5, 1).getTimezoneOffset() returns 240</pre></blockquote>
 * because on June 1, 1996, daylight saving time (Eastern Daylight Time)
 * is in use, which is offset only four hours from UTC.<p>
 * This method produces the same result as if it computed:
 * <blockquote><pre>
 * (this.getTime() - UTC(this.getYear(),
 *                       this.getMonth(),
 *                       this.getDate(),
 *                       this.getHours(),
 *                       this.getMinutes(),
 *                       this.getSeconds())) / (60 * 1000)
 * </pre></blockquote>
 *
 * @return  the time-zone offset, in minutes, for the current time zone.
 * @see     java.util.Calendar#ZONE_OFFSET
 * @see     java.util.Calendar#DST_OFFSET
 * @see     java.util.TimeZone#getDefault
 * @deprecated As of JDK version 1.1,
 * replaced by <code>-(Calendar.get(Calendar.ZONE_OFFSET) +
 * Calendar.get(Calendar.DST_OFFSET)) / (60 * 1000)</code>.
 */
@Deprecated
public int getTimezoneOffset() {
    int zoneOffset;
    if (cdate == null) {
        TimeZone tz = TimeZone.getDefaultRef();
        if (tz instanceof ZoneInfo) {
            zoneOffset = ((ZoneInfo) tz).getOffsets(fastTime, null);
        } else {
            zoneOffset = tz.getOffset(fastTime);
        }
    } else {
        normalize();
        zoneOffset = cdate.getZoneOffset();
    }
    // convert to minutes
    return -zoneOffset / 60000;
}